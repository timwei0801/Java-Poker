<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>德州撲克遊戲</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: Arial, sans-serif;
            background-color: #276c2d;
            color: white;
            padding: 20px;
        }
        .start-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #276c2d;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .start-container {
            text-align: center;
            padding: 2rem;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
        }

        .start-container h1 {
            color: white;
            margin-bottom: 2rem;
            font-size: 3rem;
        }


        .start-container button {
            padding: 1rem 2rem;
            font-size: 1.2rem;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .start-container button:hover {
            background-color: #45a049;
        }
        .game-screen {
            width: 100%;
            min-height: 100vh;
            padding: 20px;
        }

        .main-container {
            display: flex;
            gap: 20px;
            max-width: 1500px;
            margin: 0 auto;
        }

        .game-container {
            flex: 1;
        }

        .table {
            background-color: #1a4a1d; /* 更深的綠色 */
            border-radius: 200px;
            border: 8px solid #0c2e0e; /* 添加深色邊框 */
            padding: 40px;
            margin: 20px 0;
            position: relative;
            min-height: 500px; /* 調整高度 */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5); /* 添加陰影 */
        }

        /* 添加到CSS中，用於牌桌上的裝飾黑點 */
        .table-dot {
            width: 20px;
            height: 6px;
            background-color: rgba(0, 0, 0, 0.6);
            border-radius: 3px;
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
        }

        /* 上方黑點 */
        .table-dot.top {
            top: 35%;
        }

        /* 中間黑點 */
        .table-dot.middle {
            top: 50%;
        }

        /* 下方黑點 */
        .table-dot.bottom {
            bottom: 35%;
        }

        /* 公共牌區域調整 */
        .community-cards {
            display: flex;
            justify-content: center;
            gap: 12px;
            margin: 20px 0;
            min-height: 174px; /* 確保即使沒有卡牌時也保持空間 */
        }

        .card {
            width: 120px;
            height: 174px;
            border-radius: 10px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.4);
            background-color: white;
            overflow: hidden;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            position: relative;
            border: 2px solid white;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.5);
            z-index: 3;
        }

        .card img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .card.hidden {
            background-color: #b00;
            background-image: linear-gradient(45deg, #a00 25%, #c00 25%, #c00 75%, #a00 75%, #a00), 
                            linear-gradient(45deg, #a00 25%, #c00 25%, #c00 75%, #a00 75%, #a00);
            background-size: 20px 20px;
            background-position: 0 0, 10px 10px;
            border-color: #900;
        }

        .card.hidden img {
            opacity: 0;
        }

        .player-area, .bot-area {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            margin: 20px 0;
            position: relative;
            z-index: 1;
            padding: 15px;
            border-radius: 10px;
            transition: all 0.3s ease;
        }

        .player-info, .bot-info {
            position: absolute;
            left: 50px;
            background-color: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 18px;
            color: white;
            z-index: 2;
            border: 1px solid rgba(255, 255, 255, 0.15);
        }

        /* 新增籌碼數字的特殊樣式 */
        #player-chips, #bot-chips {
            color: #3a99fc; /* 籌碼數字使用藍色 */
            font-weight: bold;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        button {
            padding: 12px 24px;
            font-size: 18px;
            border: 2px solid transparent;
            border-radius: 5px;
            cursor: pointer;
            background-color: #f0f0f0;
            transition: all 0.3s ease;
            min-width: 100px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            background-color: #e0e0e0;
            transform: translateY(-2px);
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            background: #666;

        }

        #check-btn {
            background-color: #4CAF50;
            color: white;
        }

        #check-btn:hover:not(:disabled) {
            background-color: #45a049;
        }

        .pot {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 15px 25px;
            border-radius: 10px;
            z-index: 10;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        /* 添加籌碼圖示 */
        .pot:before {
            content: "";
            display: inline-block;
            width: 25px;
            height: 25px;
            background-image: url('images/chip-icon.png');
            background-size: contain;
            background-repeat: no-repeat;
        }

        .raise-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            background-color: rgba(0,0,0,0.3);
            padding: 15px;
            border-radius: 5px;
            min-width: 300px;
        }

        .raise-buttons {
            display: flex;
            gap: 10px;
            justify-content: space-between;
        }

        .raise-buttons button {
            padding: 8px 12px;
            font-size: 16px;
            min-width: 80px;
        }

        .custom-raise {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        input[type="number"] {
            width: 100%;
            padding: 8px;
            border: none;
            border-radius: 5px;
            font-size: 16px;
        }

        .game-status {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0,0,0,0.7);
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 18px;
            z-index: 3;
            white-space: nowrap;
            text-align: center;
            margin-bottom: 20px;
            animation: fadeIn 0.3s ease-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .blind-info {
            position: absolute;
            background-color: rgba(255,255,255,0.9);
            color: black;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 14px;
            font-weight: bold;
            right: -70px;
            top: 50%;
            transform: translateY(-50%);
        }

        .hand-info {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0,0,0,0.7);
            color: white;
            padding: 5px 15px;
            border-radius: 5px;
            font-size: 16px;
            bottom: -30px;
        }

        .history-panel {
            width: 300px;
            min-width: 300px;
            background-color: rgba(0,0,0,0.8);
            border-radius: 10px;
            padding: 15px;
            height: 800px;
            max-height: calc(100vh - 40px);
            margin-left: 20px;
            display: flex;
            flex-direction: column;
        }

        .history-panel h2 {
            color: white;
            font-size: 20px;
            margin-bottom: 15px;
            text-align: center;
            border-bottom: 1px solid #444;
            padding-bottom: 10px;
        }

        .history-content {
            flex: 1;
            overflow-y: auto;
            padding-right: 10px;
            scrollbar-width: thin;
            scrollbar-color: rgba(255,255,255,0.3) transparent;
        }
        /* 為 Webkit 瀏覽器添加自定義滾動條樣式 */
        .history-content::-webkit-scrollbar {
            width: 6px;
        }

        .history-content::-webkit-scrollbar-track {
            background: transparent;
        }

        .history-content::-webkit-scrollbar-thumb {
            background-color: rgba(255,255,255,0.3);
            border-radius: 3px;
        }

        .history-content::-webkit-scrollbar-thumb:hover {
            background-color: rgba(255,255,255,0.5);
        }




        .history-round {
            background-color: rgba(255,255,255,0.1);
            border-radius: 5px;
            padding: 10px;
            margin-bottom: 10px;
        }

        .round-header {
            font-weight: bold;
            color: #ffd700;
            margin-bottom: 5px;
            padding-bottom: 5px;
            border-bottom: 1px solid #444;
        }

        .action-record {
            color: white;
            font-size: 14px;
            margin: 5px 0;
            display: flex;
            justify-content: space-between;
        }

        .action-record .time {
            color: #999;
            font-size: 12px;
        }

        .action-record.player {
            color: #90caf9;
        }

        .action-record.bot {
            color: #ef9a9a;
        }

        .round-separator {
            height: 2px;
            background-color: #ffd700;
            margin: 15px 0;
        }
        .dealer-button {
            position: absolute;
            width: 30px;
            height: 30px;
            background-color: white;
            color: black;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 16px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            z-index: 3;
        }

        #player-dealer {
            left: calc(50% - 150px);
            bottom: 120px;
        }

        #bot-dealer {
            left: calc(50% - 150px);
            top: 120px;
        }

        .bet-amount {
            position: absolute;
            background-color: rgba(0,0,0,0.7);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 16px;
            color: white;
            z-index: 2;
        }

        #player-bet {
            bottom: 150px;
            left: calc(50% + 150px);  /* 改為向右偏移 */
        }

        #bot-bet {
            top: 150px;
            left: calc(50% + 150px);  /* 改為向右偏移 */
        }
        .animated-chip {
            position: fixed;
            width: 30px;
            height: 30px;
            background: #ffd700;
            border-radius: 50%;
            transition: all 0.5s ease;
            z-index: 1000;
        }

        .tooltip {
            position: fixed;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 14px;
            pointer-events: none;
            transition: opacity 0.3s;
            opacity: 0;
            z-index: 1000;
            transform: translateX(-50%);
        }

        .winner {
            animation: winner-glow 2s ease-in-out;
        }

        @keyframes winner-glow {
            0%, 100% { box-shadow: none; }
            50% { box-shadow: 0 0 30px #ffd700; }
        }

        .bet-amount {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .card {
            transition: transform 0.3s ease;
        }

        .card.winner {
            transform: scale(1.1);
        }

        .blind-info {
            background-color: rgba(255, 255, 255, 0.9);
            color: black;
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 12px;
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
        }
        .action-animation {
            position: absolute;
            color: white;
            font-size: 20px;
            opacity: 1;
            transition: all 0.5s ease;
            z-index: 1000;
            left: 50%;
            transform: translateX(-50%);
        }

        .chip-animation {
            position: fixed;
            background: gold;
            color: black;
            padding: 5px 10px;
            border-radius: 15px;
            font-weight: bold;
            transition: all 0.5s ease;
            z-index: 1000;
            transform: translate(-50%, -50%);
        }

        .button.active {
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .card.flipping {
            animation: flipCard 0.6s ease-out forwards;
            transform-style: preserve-3d;
            backface-visibility: hidden;
        }

        @keyframes flipCard {
            0% {
                transform: rotateY(0deg);
            }
            50% {
                transform: rotateY(90deg);
            }
            100% {
                transform: rotateY(180deg);
            }
        }

        @keyframes dealCard {
            0% { 
                opacity: 0;
            }
            100% {
                opacity: 1;
            }
        }
        @keyframes chipMove {
            0% { transform: scale(0.5); opacity: 0; }
            50% { transform: scale(1.2); opacity: 0.7; }
            100% { transform: scale(1); opacity: 1; }
        }
        @media (max-width: 1400px) {
            .card {
                width: 100px;
                height: 145px;
            }
            
            .community-cards {
                gap: 8px;
            }
            
            .history-panel {
                width: 250px;
                min-width: 250px;
            }
        }

        @media (max-width: 1100px) {
            .main-container {
                flex-direction: column;
            }
            
            .game-container {
                margin-bottom: 20px;
            }
            
            .history-panel {
                width: 100%;
                min-width: 100%;
                height: auto;
                max-height: 300px;
                margin-left: 0;
            }
            
            .table {
                min-height: 450px;
            }
        }

    </style>
</head>
<body>
    <!-- 開始畫面 -->
    <div id="start-screen" class="start-screen">
        <div class="start-container">
            <h1>德州撲克遊戲</h1>
            <button id="start-game-btn">開始遊戲</button>
        </div>
    </div>

    <!-- 遊戲畫面 -->
    <div id="game-screen" class="game-screen" style="display: none;">
        <div class="main-container">
            <div class="game-container">
                <div class="table">
                    <div class="table-dot top"></div>
                    <div class="table-dot middle"></div>
                    <div class="table-dot bottom"></div>
                    <div class="game-status" id="game-status"></div>
                    <div id="ai-status" class="ai-status"></div>
                    
                    <!-- 機器人區域 -->
                    <div class="bot-area">
                        <div class="bot-info">
                            機器人籌碼: <span id="bot-chips">1000</span>
                        </div>
                        <div class="dealer-button" id="bot-dealer">D</div>
                        <div class="bet-amount" id="bot-bet"></div>
                        <div class="card hidden" id="bot-card1">
                            <img src="" alt="card">
                            <div class="blind-info" id="bot-blind"></div>
                        </div>
                        <div class="card hidden" id="bot-card2">
                            <img src="" alt="card">
                        </div>
                        <div class="hand-info" id="bot-hand"></div>
                    </div>

                    <!-- 公共牌區域 -->
                    <div class="community-cards">
                        <div class="card hidden" id="community1">
                            <img src="" alt="card">
                        </div>
                        <div class="card hidden" id="community2">
                            <img src="" alt="card">
                        </div>
                        <div class="card hidden" id="community3">
                            <img src="" alt="card">
                        </div>
                        <div class="card hidden" id="community4">
                            <img src="" alt="card">
                        </div>
                        <div class="card hidden" id="community5">
                            <img src="" alt="card">
                        </div>
                    </div>

                    <!-- 底池 -->
                    <div class="pot">
                        底池: <span id="pot-amount">0</span>
                    </div>

                    <!-- 玩家區域 -->
                    <div class="player-area">
                        <div class="player-info">
                            玩家籌碼: <span id="player-chips">1000</span>
                        </div>
                        <div class="dealer-button" id="player-dealer">D</div>
                        <div class="bet-amount" id="player-bet"></div>
                        <div class="card hidden" id="player-card1">
                            <img src="" alt="card">
                            <div class="blind-info" id="player-blind"></div>
                        </div>
                        <div class="card hidden" id="player-card2">
                            <img src="" alt="card">
                        </div>
                        <div class="hand-info" id="player-hand"></div>
                    </div>

                    <!-- 控制按鈕區域 -->
                    <div class="controls">
                        <button id="check-btn" disabled>過牌</button>
                        <button id="call-btn" disabled>跟注</button>
                        <div class="raise-controls">
                            <div class="raise-buttons">
                                <button id="raise-33" disabled>33% 底池</button>
                                <button id="raise-50" disabled>50% 底池</button>
                                <button id="raise-75" disabled>75% 底池</button>
                            </div>
                            <div class="custom-raise">
                                <input type="number" id="raise-input" min="1" step="1" disabled>
                                <button id="raise-btn" disabled>確認加注</button>
                            </div>
                        </div>
                        <button id="fold-btn" disabled>棄牌</button>
                    </div>
                </div>
            </div>

            <!-- 歷史記錄面板 -->
            <div class="history-panel">
                <h2>遊戲歷史記錄</h2>
                <div class="history-content" id="history-content"></div>
            </div>
        </div>
    </div>

    <script>
        // 撲克牌類別
        class Card {
            constructor(suit, value) {
                this.suit = suit;
                this.value = value;
                const suitMap = {
                    'clubs': 'C',
                    'diamonds': 'D',
                    'hearts': 'H',
                    'spades': 'S'
                };
                const valueMap = {
                    '10': 'T'
                };
                const mappedValue = valueMap[value] || value;
                this.imagePath = `images/${mappedValue}${suitMap[suit]}.png`;
            }
    
            getImagePath() {
                return this.imagePath;
            }
        }
    
        // 牌型判定類別
        class PokerHand {
            static HAND_RANKINGS = {
                ROYAL_FLUSH: 10,
                STRAIGHT_FLUSH: 9,
                FOUR_OF_A_KIND: 8,
                FULL_HOUSE: 7,
                FLUSH: 6,
                STRAIGHT: 5,
                THREE_OF_A_KIND: 4,
                TWO_PAIR: 3,
                ONE_PAIR: 2,
                HIGH_CARD: 1
            };
    
            static CARD_VALUES = {
                '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9,
                'T': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 14
            };
    
            static evaluateHand(cards) {
                // 找出最佳的5張牌組合
                const combinations = this.findBestFiveCards(cards);
                
                const values = combinations.map(card => card.value);
                const suits = combinations.map(card => card.suit);
                
                // 檢查是否同花
                const isFlush = suits.every(suit => suit === suits[0]);
                
                // 檢查是否順子
                const valueNumbers = values.map(v => this.CARD_VALUES[v]).sort((a, b) => a - b);
                const uniqueValues = [...new Set(valueNumbers)];
                
                let isStraight = false;
                
                // 檢查一般順子
                if (uniqueValues.length >= 5) {
                    // 尋找連續5張牌
                    for (let i = 0; i <= uniqueValues.length - 5; i++) {
                        let isConsecutive = true;
                        for (let j = i; j < i + 4; j++) {
                            if (uniqueValues[j + 1] - uniqueValues[j] !== 1) {
                                isConsecutive = false;
                                break;
                            }
                        }
                        if (isConsecutive) {
                            isStraight = true;
                            break;
                        }
                    }
                }
                
                // 檢查 A-2-3-4-5 特殊順子
                if (!isStraight && uniqueValues.includes(14)) { // 有A
                    const hasFiveHighStraight = [2, 3, 4, 5].every(value => uniqueValues.includes(value));
                    if (hasFiveHighStraight) {
                        isStraight = true;
                    }
                }
                
                // 計算各個點數的出現次數
                const valueCounts = {};
                values.forEach(value => {
                    valueCounts[value] = (valueCounts[value] || 0) + 1;
                });
                
                // 判斷牌型
                if (isFlush && isStraight) {
                    // 檢查是否為皇家同花順
                    const isRoyal = values.includes('A') && values.includes('K') && 
                                    values.includes('Q') && values.includes('J') && 
                                    values.includes('T');
                    if (isRoyal) {
                        return { rank: this.HAND_RANKINGS.ROYAL_FLUSH, name: '皇家同花順', cards: combinations };
                    }
                    return { rank: this.HAND_RANKINGS.STRAIGHT_FLUSH, name: '同花順', cards: combinations };
                }
                
                if (Object.values(valueCounts).includes(4)) {
                    return { rank: this.HAND_RANKINGS.FOUR_OF_A_KIND, name: '四條', cards: combinations };
                }
                
                if (Object.values(valueCounts).includes(3) && Object.values(valueCounts).includes(2)) {
                    return { rank: this.HAND_RANKINGS.FULL_HOUSE, name: '葫蘆', cards: combinations };
                }
                
                if (isFlush) {
                    return { rank: this.HAND_RANKINGS.FLUSH, name: '同花', cards: combinations };
                }
                
                if (isStraight) {
                    return { rank: this.HAND_RANKINGS.STRAIGHT, name: '順子', cards: combinations };
                }
                
                if (Object.values(valueCounts).includes(3)) {
                    return { rank: this.HAND_RANKINGS.THREE_OF_A_KIND, name: '三條', cards: combinations };
                }
                
                const pairs = Object.values(valueCounts).filter(count => count === 2).length;
                if (pairs === 2) {
                    return { rank: this.HAND_RANKINGS.TWO_PAIR, name: '兩對', cards: combinations };
                }
                
                if (pairs === 1) {
                    return { rank: this.HAND_RANKINGS.ONE_PAIR, name: '一對', cards: combinations };
                }
                
                return { rank: this.HAND_RANKINGS.HIGH_CARD, name: '高牌', cards: combinations };
            }

            // 新增方法：尋找最佳的5張牌組合
            static findBestFiveCards(cards) {
                if (cards.length <= 5) {
                    return cards;
                }
                
                // 生成所有可能的5張牌組合
                const combinations = this.generateCombinations(cards, 5);
                
                // 評估每種組合並找出最佳者
                let bestRank = -1;
                let bestCombination = null;
                
                for (const combo of combinations) {
                    const evaluation = this.evaluateFiveCards(combo);
                    if (evaluation.rank > bestRank) {
                        bestRank = evaluation.rank;
                        bestCombination = combo;
                    } else if (evaluation.rank === bestRank) {
                        // 比較相同牌型的高牌
                        const result = this.compareSameRankHands(bestCombination, combo);
                        if (result < 0) {
                            bestCombination = combo;
                        }
                    }
                }
                
                return bestCombination;
            }

            // 生成所有可能的k張牌組合
            static generateCombinations(cards, k) {
                if (k > cards.length || k <= 0) {
                    return [];
                }
                
                if (k === cards.length) {
                    return [cards];
                }
                
                if (k === 1) {
                    return cards.map(card => [card]);
                }
                
                const result = [];
                
                for (let i = 0; i <= cards.length - k; i++) {
                    const head = cards.slice(i, i + 1);
                    const tailCombos = this.generateCombinations(cards.slice(i + 1), k - 1);
                    
                    for (const combo of tailCombos) {
                        result.push([...head, ...combo]);
                    }
                }
                
                return result;
            }

            // 評估五張牌的牌型
            static evaluateFiveCards(fiveCards) {
                // 確保只處理5張牌
                const values = fiveCards.map(card => card.value);
                const suits = fiveCards.map(card => card.suit);
                
                // 檢查是否同花
                const isFlush = suits.every(suit => suit === suits[0]);
                
                // 檢查是否順子
                const valueNumbers = values.map(v => this.CARD_VALUES[v]).sort((a, b) => a - b);
                const uniqueValues = [...new Set(valueNumbers)];
                
                let isStraight = false;
                
                // 檢查一般順子
                if (uniqueValues.length === 5) {
                    isStraight = uniqueValues[4] - uniqueValues[0] === 4;
                }
                
                // 檢查 A-2-3-4-5 特殊順子
                if (!isStraight && uniqueValues.includes(14)) {
                    const hasFiveHighStraight = [2, 3, 4, 5].every(value => uniqueValues.includes(value));
                    if (hasFiveHighStraight) {
                        isStraight = true;
                    }
                }
                
                // 計算各個點數的出現次數
                const valueCounts = {};
                values.forEach(value => {
                    valueCounts[value] = (valueCounts[value] || 0) + 1;
                });
                
                // 判斷牌型
                if (isFlush && isStraight) {
                    const isRoyal = values.includes('A') && values.includes('K') && 
                                    values.includes('Q') && values.includes('J') && 
                                    values.includes('T');
                    if (isRoyal) {
                        return { rank: this.HAND_RANKINGS.ROYAL_FLUSH, name: '皇家同花順', cards: fiveCards };
                    }
                    return { rank: this.HAND_RANKINGS.STRAIGHT_FLUSH, name: '同花順', cards: fiveCards };
                }
                
                if (Object.values(valueCounts).includes(4)) {
                    return { rank: this.HAND_RANKINGS.FOUR_OF_A_KIND, name: '四條', cards: fiveCards };
                }
                
                if (Object.values(valueCounts).includes(3) && Object.values(valueCounts).includes(2)) {
                    return { rank: this.HAND_RANKINGS.FULL_HOUSE, name: '葫蘆', cards: fiveCards };
                }
                
                if (isFlush) {
                    return { rank: this.HAND_RANKINGS.FLUSH, name: '同花', cards: fiveCards };
                }
                
                if (isStraight) {
                    return { rank: this.HAND_RANKINGS.STRAIGHT, name: '順子', cards: fiveCards };
                }
                
                if (Object.values(valueCounts).includes(3)) {
                    return { rank: this.HAND_RANKINGS.THREE_OF_A_KIND, name: '三條', cards: fiveCards };
                }
                
                const pairs = Object.values(valueCounts).filter(count => count === 2).length;
                if (pairs === 2) {
                    return { rank: this.HAND_RANKINGS.TWO_PAIR, name: '兩對', cards: fiveCards };
                }
                
                if (pairs === 1) {
                    return { rank: this.HAND_RANKINGS.ONE_PAIR, name: '一對', cards: fiveCards };
                }
                
                return { rank: this.HAND_RANKINGS.HIGH_CARD, name: '高牌', cards: fiveCards };
            }

            // 比較相同牌型的高牌
            static compareSameRankHands(hand1, hand2) {
                const values1 = hand1.map(card => this.CARD_VALUES[card.value]).sort((a, b) => b - a);
                const values2 = hand2.map(card => this.CARD_VALUES[card.value]).sort((a, b) => b - a);
                
                for (let i = 0; i < values1.length; i++) {
                    if (values1[i] > values2[i]) return 1;
                    if (values1[i] < values2[i]) return -1;
                }
                
                return 0;
            }

            // 比較兩手牌 - 修正了重複定義的問題
            static compareHands(hand1Cards, hand2Cards) {
                const hand1 = this.evaluateHand(hand1Cards);
                const hand2 = this.evaluateHand(hand2Cards);
                
                // 先比較牌型等級
                if (hand1.rank > hand2.rank) return 1;
                if (hand1.rank < hand2.rank) return -1;
                
                // 牌型相同時比較高牌
                const values1 = hand1Cards.map(card => 
                    this.CARD_VALUES[card.value === 'T' ? '10' : card.value])
                    .sort((a, b) => b - a);
                const values2 = hand2Cards.map(card => 
                    this.CARD_VALUES[card.value === 'T' ? '10' : card.value])
                    .sort((a, b) => b - a);
                
                for (let i = 0; i < Math.min(values1.length, values2.length); i++) {
                    if (values1[i] > values2[i]) return 1;
                    if (values1[i] < values2[i]) return -1;
                }
                
                return 0;
            }
        }
    
        // 牌堆類別
        class Deck {
            constructor() {
                this.cards = [];
                const suits = ['clubs', 'diamonds', 'hearts', 'spades'];
                const values = ['2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A'];
                
                for (let suit of suits) {
                    for (let value of values) {
                        this.cards.push(new Card(suit, value));
                    }
                }
            }
    
            shuffle() {
                for (let i = this.cards.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [this.cards[i], this.cards[j]] = [this.cards[j], this.cards[i]];
                }
            }
    
            deal() {
                return this.cards.pop();
            }
        }
    
        // 遊戲主類別開始
        class Game {
            debugGameState() {
                console.log('Game State Debug:', {
                    currentActor: this.currentActor,
                    gameState: this.gameState,
                    isAutoPlaying: this.isAutoPlaying,
                    currentBetAmount: this.currentBetAmount,
                    currentPlayerBet: this.currentPlayerBet,
                    currentBotBet: this.currentBotBet,
                    playerChips: this.playerChips,
                    botChips: this.botChips,
                    pot: this.pot
                });
            }

            constructor() {
                this.deck = new Deck();
                this.playerChips = 1000;
                this.botChips = 1000;
                this.pot = 0;
                this.playerHand = [];
                this.botHand = [];
                this.communityCards = [];
                this.gameState = 'waiting';  // waiting, preflop, flop, turn, river, showdown
                this.roundCount = 0;
                this.isAutoPlaying = false;
                this.isPlayerDealer = true;
                this.currentRoundActions = [];
                this.roundHistory = [];
                this.SMALL_BLIND = 10;
                this.BIG_BLIND = 20;
                this.currentActor = null;
                // 新增盲注和位置相關的狀態
                this.smallBlindPosition = null;  // 小盲位置
                this.bigBlindPosition = null;    // 大盲位置
                this.currentBetRound = 0;        // 當前下注輪次
                this.lastRaiseAmount = 0;        // 上一次加注金額
                // 下注相關狀態
                this.currentBetAmount = 0;  // 當前回合的下注金額
                this.lastBetPlayer = null;  // 最後下注的玩家
                this.actionsThisStreet = []; // 當前街的行動記錄
                this.currentPlayerBet = 0;   // 玩家在當前回合的下注總額
                this.currentBotBet = 0;      // 機器人在當前回合的下注總額

                this.burnCards = [];  // 銷牌堆
                this.lastBetterPreflop = null;  // 記錄翻牌前最後行動者
                this.dealerPosition = 'player';  // 初始莊家位置
                this.streetActions = new Set();  // 記錄當前街口誰行動過
                this.currentStreet = 'preflop';  // 當前街口
                this.isActionInProgress = false;  // 防止連續行動的標誌
                // 初始化時執行
                this.initialize();
            }

            // 在 Game 類別中新增以下函數
            revealCard(cardElement, cardData) {
                // 確保卡牌一開始是隱藏狀態（顯示背面）
                cardElement.classList.add('flipping');
                
                // 在動畫中途（當卡牌處於垂直狀態）才更新卡牌內容
                setTimeout(() => {
                    cardElement.classList.remove('hidden');
                    if (cardData && cardElement.querySelector('img')) {
                        cardElement.querySelector('img').src = cardData.getImagePath();
                    }
                }, 300); // 動畫中點
                
                // 動畫結束後移除動畫類
                setTimeout(() => {
                    cardElement.classList.remove('flipping');
                }, 600);
            }
            
            initialize() {
                // 等待 DOM 加載完成
                if (document.readyState === 'loading') {
                    document.addEventListener('DOMContentLoaded', () => this.setupEventListeners());
                } else {
                    this.setupEventListeners();
                }
            }
            setupEventListeners() {
                // 綁定開始遊戲按鈕
                const startButton = document.getElementById('start-game-btn');
                if (startButton) {
                    startButton.addEventListener('click', () => this.startGame());
                }

                // 綁定其他按鈕
                this.initializeGameControls();
            }
            // 新增初始化遊戲方法
            initializeGame() {
                const startButton = document.getElementById('start-game-btn');
                if (startButton) {
                    startButton.addEventListener('click', () => {
                        this.startGame();
                    });
                }

                // 初始化按鈕事件
                this.initializeGameControls();
            }

            // 新增開始遊戲方法
            startGame() {
                console.log('Starting game...'); // 調試用

                // 隱藏開始畫面
                const startScreen = document.getElementById('start-screen');
                if (startScreen) {
                    startScreen.style.display = 'none';
                }

                // 顯示遊戲畫面
                const gameScreen = document.getElementById('game-screen');
                if (gameScreen) {
                    gameScreen.style.display = 'block';
                }

                // 確保遊戲控件初始化
                this.initializeGameControls();

                // 開始新的一局
                this.startNewHand();

                // 更新顯示
                this.updateDisplay();
                this.updateGameStatus('遊戲開始');
            }
            // [新增] 檢查按鈕是否存在的方法
            checkButtonsExist() {
                const requiredButtons = [
                    'check-btn', 
                    'call-btn', 
                    'raise-33', 
                    'raise-50', 
                    'raise-75',
                    'raise-btn', 
                    'fold-btn',
                    'raise-input'
                ];

                const missingButtons = requiredButtons.filter(id => !document.getElementById(id));
                if (missingButtons.length > 0) {
                    console.error('Missing buttons:', missingButtons);
                    return false;
                }
                return true;
            }

            // 更新初始化按鈕方法名稱和內容
            initializeGameControls() {
                // 使用函數來創建去抖動（debounce）的點擊處理器
                const createDebouncedHandler = (handler) => {
                    let isProcessing = false;
                    return (...args) => {
                        if (isProcessing) return;
                        isProcessing = true;
                        handler(...args);
                        // 1秒後重置狀態
                        setTimeout(() => {
                            isProcessing = false;
                        }, 1000);
                    };
                };

                // 為每個按鈕添加去抖動的事件處理
                const buttonBindings = {
                    'check-btn': () => this.playerCheck(),
                    'call-btn': () => this.playerCall(),
                    'fold-btn': () => this.playerFold(),
                    'raise-33': () => this.playerRaiseCustom(Math.floor(this.pot * 0.33)),
                    'raise-50': () => this.playerRaiseCustom(Math.floor(this.pot * 0.5)),
                    'raise-75': () => this.playerRaiseCustom(Math.floor(this.pot * 0.75)),
                    'raise-btn': () => {
                        const amount = parseInt(document.getElementById('raise-input').value);
                        if (amount && amount > 0) {
                            this.playerRaiseCustom(amount);
                        }
                    }
                };

                // 重新綁定按鈕事件（避免重複綁定）
                Object.entries(buttonBindings).forEach(([id, handler]) => {
                    const button = document.getElementById(id);
                    if (button) {
                        const debouncedHandler = createDebouncedHandler(handler);
                        const newButton = button.cloneNode(true);
                        button.parentNode.replaceChild(newButton, button);
                        newButton.addEventListener('click', debouncedHandler);
                    }
                });

                // 初始化加注輸入控件
                this.initializeRaiseControls();
            }
            startNewGame() {
                const startScreen = document.getElementById('start-screen');
                const gameScreen = document.getElementById('game-screen');
                
                startScreen.style.display = 'none';
                gameScreen.style.display = 'flex';
                
                this.resetGame();
                this.startNewHand();
            }

            updateDealerPosition() {
                // 更新莊家按鈕顯示
                const playerDealer = document.getElementById('player-dealer');
                const botDealer = document.getElementById('bot-dealer');
                
                console.log('Current dealer position:', this.dealerPosition); // 調試用

                if (this.dealerPosition === 'player') {
                    playerDealer.style.display = 'flex';
                    botDealer.style.display = 'none';
                } else {
                    playerDealer.style.display = 'none';
                    botDealer.style.display = 'flex';
                }

                // 更新遊戲狀態顯示中的莊家資訊
                this.updateGameStatus(
                    `第 ${this.roundCount} 局 - ${this.dealerPosition === 'player' ? '玩家' : '機器人'}是莊家`
                );
            }

            // 修改 initializeRaiseControls 方法
            initializeRaiseControls() {
                const raiseInput = document.getElementById('raise-input');
                const raiseBtn = document.getElementById('raise-btn');

                // 使用去抖動的輸入處理
                let inputTimeout;
                raiseInput.addEventListener('input', () => {
                    clearTimeout(inputTimeout);
                    inputTimeout = setTimeout(() => {
                        let value = parseInt(raiseInput.value);
                        if (isNaN(value) || value < this.getMinRaiseAmount()) {
                            value = this.getMinRaiseAmount();
                        }
                        if (value > this.playerChips) {
                            value = this.playerChips;
                        }
                        raiseInput.value = value;
                    }, 300);
                });
            }

            // 更新可以加注的條件檢查
            canRaise(player) {
                if (this.currentActor !== player) return false;
                
                const chips = player === 'player' ? this.playerChips : this.botChips;
                const currentBet = player === 'player' ? this.currentPlayerBet : this.currentBotBet;
                const minRaise = this.getMinRaiseAmount();
                
                console.log('Raise check:', {
                    player,
                    chips,
                    currentBet,
                    minRaise,
                    canRaise: chips >= (minRaise - currentBet)
                });
                
                return chips >= (minRaise - currentBet);
            }

            // 更新遊戲狀態顯示
            updateGameStatus(message) {
                const statusElement = document.getElementById('game-status');
                const phases = {
                    'waiting': '等待開始',
                    'preflop': '翻牌前',
                    'flop': '翻牌圈',
                    'turn': '轉牌圈',
                    'river': '河牌圈',
                    'showdown': '攤牌'
                };

                const position = this.dealerPosition === 'player' ? '你是莊家' : '機器人是莊家';
                const phase = phases[this.gameState] || '';
                const currentActor = this.currentActor === 'player' ? '輪到你行動' : '輪到機器人行動';
                const betInfo = this.currentBetAmount > 0 ? 
                    ` - 當前下注：${this.currentBetAmount}` : '';
                
                statusElement.textContent = `第 ${this.roundCount} 局 - ${position} - ${phase} - ${currentActor}${betInfo} - ${message}`;
            }
            addAnimatedChips(amount, from, to) {
                const chip = document.createElement('div');
                chip.className = 'animated-chip';
                document.body.appendChild(chip);

                const fromRect = from.getBoundingClientRect();
                const toRect = to.getBoundingClientRect();

                chip.style.left = `${fromRect.left + fromRect.width/2}px`;
                chip.style.top = `${fromRect.top + fromRect.height/2}px`;

                setTimeout(() => {
                    chip.style.left = `${toRect.left + toRect.width/2}px`;
                    chip.style.top = `${toRect.top + toRect.height/2}px`;
                }, 50);

                setTimeout(() => {
                    document.body.removeChild(chip);
                }, 500);
            }
            addTooltip(element, text) {
                const tooltip = document.createElement('div');
                tooltip.className = 'tooltip';
                tooltip.textContent = text;
                document.body.appendChild(tooltip);

                element.addEventListener('mouseover', (e) => {
                    const rect = element.getBoundingClientRect();
                    tooltip.style.left = `${rect.left + rect.width/2}px`;
                    tooltip.style.top = `${rect.top - 30}px`;
                    tooltip.style.opacity = '1';
                });

                element.addEventListener('mouseout', () => {
                    tooltip.style.opacity = '0';
                });
            }
            showWinnerAnimation(winner) {
                const element = winner === 'player' ? 
                    document.querySelector('.player-area') : 
                    document.querySelector('.bot-area');
                    
                element.classList.add('winner');
                setTimeout(() => {
                    element.classList.remove('winner');
                }, 2000);
            }
            
            addActionRecord(player, action, amount = null) {
                const time = new Date().toLocaleTimeString();
                const record = {
                    time,
                    player,
                    action,
                    amount,
                    roundNumber: this.roundCount,
                    // 加入當前莊家資訊
                    dealerPosition: this.dealerPosition
                };
                this.currentRoundActions.push(record);
                this.updateHistoryDisplay();
            }

            // 修改 updateHistoryDisplay 方法
            updateHistoryDisplay() {
                const historyContent = document.getElementById('history-content');
                let html = '';

                if (this.currentRoundActions.length > 0) {
                    html += `
                        <div class="history-round">
                            <div class="round-header">第 ${this.roundCount} 局 (${this.currentRoundActions[0].dealerPosition === 'player' ? '玩家' : '機器人'}是莊家)</div>
                            ${this.currentRoundActions.map(record => `
                                <div class="action-record ${record.player.toLowerCase()}">
                                    <span>${record.player} ${record.action}${record.amount ? ` $${record.amount}` : ''}</span>
                                    <span class="time">${record.time}</span>
                                </div>
                            `).join('')}
                        </div>
                    `;
                }

                // 顯示歷史紀錄
                html += this.roundHistory.map(round => `
                    <div class="round-separator"></div>
                    <div class="history-round">
                        <div class="round-header">第 ${round.roundNumber} 局 (${round.dealerPosition === 'player' ? '玩家' : '機器人'}是莊家)</div>
                        ${round.actions.map(record => `
                            <div class="action-record ${record.player.toLowerCase()}">
                                <span>${record.player} ${record.action}${record.amount ? ` $${record.amount}` : ''}</span>
                                <span class="time">${record.time}</span>
                            </div>
                        `).join('')}
                    </div>
                `).join('');

                historyContent.innerHTML = html;
                // 保持滾動位置在底部
                historyContent.scrollTop = historyContent.scrollHeight;
                
                // 添加滾動事件監聽器來記住用戶的滾動位置
                let userHasScrolled = false;
                historyContent.addEventListener('scroll', () => {
                    userHasScrolled = true;
                    // 如果用戶滾動到底部，重置標記
                    if (historyContent.scrollHeight - historyContent.scrollTop === historyContent.clientHeight) {
                        userHasScrolled = false;
                    }
                });
                
                // 只有在用戶沒有手動滾動時，才自動滾動到底部
                if (!userHasScrolled) {
                    historyContent.scrollTop = historyContent.scrollHeight;
                }
            }

            updateDisplay() {
                // 更新玩家手牌
                const playerCard1 = document.querySelector('#player-card1');
                const playerCard2 = document.querySelector('#player-card2');
                
                if (this.playerHand.length > 0) {
                    if (playerCard1.classList.contains('hidden') && !playerCard1.hasAttribute('data-animating')) {
                        playerCard1.setAttribute('data-animating', 'true');
                        this.revealCard(playerCard1, this.playerHand[0]);
                        setTimeout(() => {
                            playerCard1.removeAttribute('data-animating');
                        }, 600);
                    } else if (!playerCard1.classList.contains('hidden')) {
                        playerCard1.querySelector('img').src = this.playerHand[0].getImagePath();
                    }
                    
                    if (playerCard2.classList.contains('hidden') && !playerCard2.hasAttribute('data-animating')) {
                        playerCard2.setAttribute('data-animating', 'true');
                        this.revealCard(playerCard2, this.playerHand[1]);
                        setTimeout(() => {
                            playerCard2.removeAttribute('data-animating');
                        }, 600);
                    } else if (!playerCard2.classList.contains('hidden')) {
                        playerCard2.querySelector('img').src = this.playerHand[1].getImagePath();
                    }
                } else {
                    playerCard1.classList.add('hidden');
                    playerCard2.classList.add('hidden');
                }

                // 更新機器人手牌
                const botCard1 = document.querySelector('#bot-card1');
                const botCard2 = document.querySelector('#bot-card2');
                
                if (this.gameState === 'showdown' && this.botHand.length > 0) {
                    if (botCard1.classList.contains('hidden') && !botCard1.hasAttribute('data-animating')) {
                        botCard1.setAttribute('data-animating', 'true');
                        this.revealCard(botCard1, this.botHand[0]);
                        setTimeout(() => {
                            botCard1.removeAttribute('data-animating');
                        }, 600);
                    } else if (!botCard1.classList.contains('hidden')) {
                        botCard1.querySelector('img').src = this.botHand[0].getImagePath();
                    }
                    
                    if (botCard2.classList.contains('hidden') && !botCard2.hasAttribute('data-animating')) {
                        botCard2.setAttribute('data-animating', 'true');
                        this.revealCard(botCard2, this.botHand[1]);
                        setTimeout(() => {
                            botCard2.removeAttribute('data-animating');
                        }, 600);
                    } else if (!botCard2.classList.contains('hidden')) {
                        botCard2.querySelector('img').src = this.botHand[1].getImagePath();
                    }
                } else {
                    botCard1.classList.add('hidden');
                    botCard2.classList.add('hidden');
                }

                // 更新公共牌
                for (let i = 0; i < 5; i++) {
                    const communityCard = document.querySelector(`#community${i+1}`);
                    if (this.communityCards[i]) {
                        if (communityCard.classList.contains('hidden') && !communityCard.hasAttribute('data-animating')) {
                            communityCard.setAttribute('data-animating', 'true');
                            this.revealCard(communityCard, this.communityCards[i]);
                            setTimeout(() => {
                                communityCard.removeAttribute('data-animating');
                            }, 600);
                        } else if (!communityCard.classList.contains('hidden')) {
                            communityCard.querySelector('img').src = this.communityCards[i].getImagePath();
                        }
                    } else {
                        communityCard.classList.add('hidden');
                    }
                }

                // 更新籌碼和底池
                document.getElementById('player-chips').textContent = this.playerChips;
                document.getElementById('bot-chips').textContent = this.botChips;
                document.getElementById('pot-amount').textContent = this.pot;

                // 更新盲注顯示
                document.getElementById('player-blind').textContent = 
                    this.bigBlindPosition === 'player' ? `大盲 ${this.BIG_BLIND}` : 
                    this.smallBlindPosition === 'player' ? `小盲 ${this.SMALL_BLIND}` : '';
                
                document.getElementById('bot-blind').textContent = 
                    this.bigBlindPosition === 'bot' ? `大盲 ${this.BIG_BLIND}` : 
                    this.smallBlindPosition === 'bot' ? `小盲 ${this.SMALL_BLIND}` : '';
                
                // 更新莊家按鈕顯示
                document.getElementById('player-dealer').style.display = 
                    this.dealerPosition === 'player' ? 'flex' : 'none';
                document.getElementById('bot-dealer').style.display = 
                    this.dealerPosition === 'bot' ? 'flex' : 'none';

                // 更新下注金額顯示
                document.getElementById('player-bet').textContent = 
                    this.currentPlayerBet > 0 ? `下注: ${this.currentPlayerBet}` : '';
                document.getElementById('bot-bet').textContent = 
                    this.currentBotBet > 0 ? `下注: ${this.currentBotBet}` : '';
                
                // 更新按鈕狀態
                this.updateButtonStates();

                // 更新加注輸入框
                const raiseInput = document.getElementById('raise-input');
                if (raiseInput) {
                    raiseInput.max = this.playerChips;
                    raiseInput.value = Math.min(this.getMinRaiseAmount(), this.playerChips);
                }
            }

            // 修改按鈕啟用狀態
            updateButtonStates() {
                // 如果不是玩家回合，禁用所有按鈕
                if (this.currentActor !== 'player') {
                    this.disableAllButtons();
                    return;
                }

                const callAmount = this.currentBetAmount - this.currentPlayerBet;
                console.log('Current game state:', {
                    gameState: this.gameState,
                    currentActor: this.currentActor,
                    bigBlindPosition: this.bigBlindPosition,
                    currentBetAmount: this.currentBetAmount,
                    currentPlayerBet: this.currentPlayerBet,
                    currentBotBet: this.currentBotBet
                });

                // 決定按鈕狀態
                const buttonStates = {
                    'check-btn': this.canCheck('player'),
                    'call-btn': callAmount > 0 && this.playerChips > 0,
                    'fold-btn': callAmount > 0,  // 修正：只有當需要跟注時才能棄牌
                    'raise-33': this.canRaise('player'),
                    'raise-50': this.canRaise('player'),
                    'raise-75': this.canRaise('player'),
                    'raise-btn': this.canRaise('player')
                };

                // 更新按鈕狀態
                Object.entries(buttonStates).forEach(([id, enabled]) => {
                    const button = document.getElementById(id);
                    if (button) {
                        button.disabled = !enabled;
                        button.classList.toggle('disabled', !enabled);
                        if (enabled) {
                            button.style.opacity = '1';
                            button.style.cursor = 'pointer';
                        } else {
                            button.style.opacity = '0.5';
                            button.style.cursor = 'not-allowed';
                        }
                    }
                });

                // 更新跟注按鈕文字
                const callBtn = document.getElementById('call-btn');
                if (callBtn && callAmount > 0) {
                    callBtn.textContent = `跟注 $${callAmount}`;
                }

                // 更新加注輸入框
                const raiseInput = document.getElementById('raise-input');
                if (raiseInput) {
                    const canRaise = this.canRaise('player');
                    raiseInput.disabled = !canRaise;
                    if (canRaise) {
                        raiseInput.min = this.getMinRaiseAmount();
                        raiseInput.max = this.playerChips;
                        raiseInput.value = Math.min(this.getMinRaiseAmount(), this.playerChips);
                    }
                }
            }
            // 修改行動者切換邏輯
            setCurrentActor(actor) {
                console.log('Setting current actor to:', actor);
                this.currentActor = actor;
                
                if (actor === 'player') {
                    // 移除對不存在方法的呼叫
                    this.updateButtonStates();
                    this.updateGameStatus('輪到玩家行動');
                } else {
                    this.disableAllButtons();
                    this.updateGameStatus('輪到機器人行動');
                    setTimeout(() => this.botAction(), 1000);
                }
            }
            // 新增禁用所有按鈕的方法
            disableAllButtons() {
                const buttonIds = ['check-btn', 'call-btn', 'fold-btn', 'raise-33', 'raise-50', 'raise-75', 'raise-btn', 'raise-input'];
                buttonIds.forEach(id => {
                    const button = document.getElementById(id);
                    if (button) {
                        button.disabled = true;
                        button.classList.add('disabled');
                    }
                });
            }
            
            // 檢查過牌是否合法 - 修正邏輯
            canCheck(player) {
                // 檢查是否為當前行動者
                if (this.currentActor !== player) {
                    return false;
                }

                // 如果當前沒有任何下注，始終可以過牌
                if (this.currentBetAmount === 0) {
                    return true;
                }

                // 如果雙方下注金額相等，且不為0，在翻牌前階段需要特殊處理
                if (this.currentPlayerBet === this.currentBotBet) {
                    if (this.gameState === 'preflop') {
                        // 翻牌前只有大盲位置可以過牌
                        return player === this.bigBlindPosition && 
                            this.currentBetAmount === this.BIG_BLIND;
                    }
                    return true;
                }

                return false;
            }
            
            // 計算最小加注金額的方法
            getMinRaiseAmount() {
                // 如果已經有人加注
                if (this.currentBetAmount > 0) {
                    // 最小加注必須大於當前最大注額
                    return this.currentBetAmount + this.BIG_BLIND;
                }
                // 如果沒有人加注，則最小加注為大盲注
                return this.BIG_BLIND;
            }

            // 修改 startNewHand 方法，移除清空歷史記錄的部分
            startNewHand() {
                // 檢查是否可以開始新的一局
                if (this.playerChips < this.BIG_BLIND || this.botChips < this.BIG_BLIND) {
                    alert('籌碼不足，無法繼續遊戲！');
                    this.resetGame();
                    return;
                }
                // 將當前回合的記錄加入歷史記錄中
                if (this.currentRoundActions.length > 0) {
                    this.roundHistory.unshift({
                        roundNumber: this.roundCount,
                        actions: [...this.currentRoundActions],
                        dealerPosition: this.dealerPosition
                    });
                }

                // 增加局數
                this.roundCount++;

                // 準備牌局
                this.deck = new Deck();
                this.deck.shuffle();

                // 重置當前局的狀態
                this.pot = 0;
                this.playerHand = [];
                this.botHand = [];
                this.communityCards = [];
                this.burnCards = [];
                this.currentBetAmount = 0;
                this.currentPlayerBet = 0;
                this.currentBotBet = 0;
                this.lastBetPlayer = null;
                this.streetActions = new Set();
                this.currentRoundActions = [];  // 只清空當前局的行動記錄
                
                // 設置遊戲狀態
                this.gameState = 'preflop';
                this.currentStreet = 'preflop';

                // 在每局開始時輪換莊家位置
                this.dealerPosition = this.roundCount % 2 === 1 ? 'player' : 'bot';
                
                // 根據莊家位置設置盲注
                if (this.dealerPosition === 'player') {
                    this.smallBlindPosition = 'bot';
                    this.bigBlindPosition = 'player';
                } else {
                    this.smallBlindPosition = 'player';
                    this.bigBlindPosition = 'bot';
                }

                // 更新莊家按鈕顯示
                this.updateDealerPosition();

                // 發牌
                this.dealInitialCards();

                // 設置盲注
                this.setInitialBlinds();

                // 決定首位行動者
                this.determineFirstActor();

                // 更新顯示
                this.updateDisplay();
                this.updateGameStatus(`第 ${this.roundCount} 局開始`);
            }

            setInitialBlinds() {
                if (this.dealerPosition === 'player') {
                    // 機器人付小盲
                    this.botChips -= this.SMALL_BLIND;
                    this.currentBotBet = this.SMALL_BLIND;
                    this.addActionRecord('機器人', '小盲注', this.SMALL_BLIND);
                    
                    // 玩家付大盲
                    this.playerChips -= this.BIG_BLIND;
                    this.currentPlayerBet = this.BIG_BLIND;
                    this.addActionRecord('玩家', '大盲注', this.BIG_BLIND);
                } else {
                    // 玩家付小盲
                    this.playerChips -= this.SMALL_BLIND;
                    this.currentPlayerBet = this.SMALL_BLIND;
                    this.addActionRecord('玩家', '小盲注', this.SMALL_BLIND);
                    
                    // 機器人付大盲
                    this.botChips -= this.BIG_BLIND;
                    this.currentBotBet = this.BIG_BLIND;
                    this.addActionRecord('機器人', '大盲注', this.BIG_BLIND);
                }
                
                this.pot = this.SMALL_BLIND + this.BIG_BLIND;
                this.currentBetAmount = this.BIG_BLIND;
                
                // 更新顯示
                this.updateDisplay();
                this.updateButtonStates();
            }

            // 新增 updateDealerButton 方法
            updateDealerButton() {
                // 更新莊家按鈕顯示
                const playerDealerBtn = document.getElementById('player-dealer');
                const botDealerBtn = document.getElementById('bot-dealer');
                
                // 根據莊家位置顯示/隱藏按鈕
                playerDealerBtn.style.display = this.dealerPosition === 'player' ? 'flex' : 'none';
                botDealerBtn.style.display = this.dealerPosition === 'bot' ? 'flex' : 'none';

                // 更新盲注顯示
                document.getElementById('player-blind').textContent = 
                    this.bigBlindPosition === 'player' ? 
                        `大盲 ${this.BIG_BLIND}` : 
                        this.smallBlindPosition === 'player' ? 
                            `小盲 ${this.SMALL_BLIND}` : '';
                        
                document.getElementById('bot-blind').textContent = 
                    this.bigBlindPosition === 'bot' ? 
                        `大盲 ${this.BIG_BLIND}` : 
                        this.smallBlindPosition === 'bot' ? 
                            `小盲 ${this.SMALL_BLIND}` : '';
            }
            
            dealInitialCards() {
                // 清空現有手牌
                this.playerHand = [];
                this.botHand = [];
                
                // 決定發牌順序
                const dealSequence = this.dealerPosition === 'player' ? 
                    ['bot-card1', 'player-card1', 'bot-card2', 'player-card2'] : 
                    ['player-card1', 'bot-card1', 'player-card2', 'bot-card2'];
                
                // 發牌並設置延遲
                dealSequence.forEach((cardId, index) => {
                    setTimeout(() => {
                        if (cardId.includes('player')) {
                            const cardIndex = cardId.includes('1') ? 0 : 1;
                            if (this.playerHand.length <= cardIndex) {
                                this.playerHand.push(this.deck.deal());
                            }
                            const card = this.playerHand[cardIndex];
                            const cardElement = document.getElementById(cardId);
                            // 使用修改後的 revealCard 方法顯示牌面
                            this.revealCard(cardElement, card);
                        } else {
                            const cardIndex = cardId.includes('1') ? 0 : 1;
                            if (this.botHand.length <= cardIndex) {
                                this.botHand.push(this.deck.deal());
                            }
                            // 機器人的牌直接保持隱藏狀態，不使用翻轉動畫
                            const cardElement = document.getElementById(cardId);
                            // 不添加翻牌動畫，維持隱藏狀態
                        }
                    }, index * 300); // 每張牌間隔300毫秒
                });
            }
            // 遊戲進程控制改進
            determineFirstActor() {
                // 決定誰先行動
                if (this.gameState === 'preflop') {
                    // 翻牌前從大盲位置後一位開始行動
                    this.currentActor = this.dealerPosition === 'player' ? 'bot' : 'player';
                } else {
                    // 翻牌後從莊家後一位開始行動
                    this.currentActor = this.dealerPosition === 'player' ? 'bot' : 'player';
                }

                // 根據當前行動者更新狀態
                this.updateGameStatus(`輪到${this.currentActor === 'player' ? '玩家' : '機器人'}行動`);

                // 更新按鈕狀態
                this.updateButtonStates();

                // 如果是機器人回合，執行機器人行動
                if (this.currentActor === 'bot') {
                    setTimeout(() => this.botAction(), 1000);
                }
            }

            playerCheck() {
                if (this.currentActor !== 'player') return;
                if (!this.canCheck('player')) return;
                
                this.addActionRecord('玩家', '過牌');
                this.actionsThisStreet.push({player: 'player', action: 'check'});
                this.streetActions.add('player');
                this.lastAction = 'check';
                
                console.log('Player checked, checking if can progress', {
                    botHasChecked: this.streetActions.has('bot'),
                    everyoneActed: this.hasEveryoneActed()
                });
                
                if (this.hasEveryoneActed()) {
                    this.progressGame();
                } else {
                    this.currentActor = 'bot';
                    setTimeout(() => this.botAction(), 1000);
                }
                
                this.updateDisplay();
            }
            
            playerCall() {
                if (this.currentActor !== 'player' || this.isActionInProgress) {
                    return;
                }
                if (this.currentBetAmount === 0) return;
                
                const callAmount = this.currentBetAmount - this.currentPlayerBet;
                if (callAmount <= 0) return;

                const actualCallAmount = Math.min(callAmount, this.playerChips);
                this.pot += actualCallAmount;
                this.playerChips -= actualCallAmount;
                this.currentPlayerBet = this.currentBetAmount;
                this.streetActions.add('player');

                this.addActionRecord('玩家', '跟注', actualCallAmount);

                if (this.playerChips === 0) {
                    this.addActionRecord('玩家', '全壓');
                    this.autoPlayToEnd();
                } else if (this.hasEveryoneActed()) {
                    this.progressGame();
                } else {
                    this.currentActor = 'bot';
                    setTimeout(() => this.botAction(), 1000);
                }
                
                this.updateDisplay();
            }

            // 玩家加注方法 - 修正計算邏輯
            playerRaiseCustom(amount) {
            // 如果不是玩家回合或正在執行行動，直接返回
            if (this.currentActor !== 'player' || this.isActionInProgress) {
                return;
            }
            
            // 設置行動進行中標誌
            this.isActionInProgress = true;
            
            // 計算新的總下注額 (當前玩家已下注金額 + 玩家想要加注的金額)
            const newTotalBet = this.currentPlayerBet + amount;
            
            // 計算最小加注總額 (當前最高下注金額 + 最小加注增量)
            const minRaiseTotal = this.currentBetAmount + this.BIG_BLIND;
            
            // 檢查是否達到最小加注要求
            if (newTotalBet < minRaiseTotal) {
                this.isActionInProgress = false;
                alert(`最小加注總額必須是 $${minRaiseTotal}`);
                return;
            }

            // 檢查是否超過玩家籌碼
            if (amount > this.playerChips) {
                this.isActionInProgress = false;
                alert('籌碼不足');
                return;
            }
            
            // 更新遊戲狀態
            this.pot += amount;
            this.playerChips -= amount;
            this.lastRaiseAmount = this.currentBetAmount;
            this.currentPlayerBet += amount;  // 加上加注金額，而不是直接設為 amount
            this.currentBetAmount = this.currentPlayerBet;  // 更新當前下注金額
            this.lastBetPlayer = 'player';
            this.streetActions.add('player');
            
            this.addActionRecord('玩家', '加注', amount);
            
            // 檢查是否全下
            if (this.playerChips === 0) {
                this.addActionRecord('玩家', '全壓');
                this.autoPlayToEnd();
                this.isActionInProgress = false;
                return;
            }
            
            // 換成機器人的回合
            this.currentActor = 'bot';
            this.updateDisplay();
            setTimeout(() => {
                this.isActionInProgress = false;
                this.botAction();
            }, 1000);
        }

            playerFold() {
                if (this.currentActor !== 'player' || this.isActionInProgress || !this.canFold()) {
                    return;
                }
                
                this.botChips += this.pot;
                this.pot = 0;
                this.addActionRecord('玩家', '棄牌');
                this.gameState = 'showdown';
                this.updateDisplay();
                
                setTimeout(() => {
                    if (this.playerChips <= 0) {
                        alert('你輸光了所有籌碼！遊戲結束！');
                        this.resetGame();
                    } else {
                        this.startNewHand();
                    }
                }, 1500);
            }

            // 修改機器人行動方法，確保正確切換到玩家回合
            botAction() {
                if (this.currentActor !== 'bot' || this.isActionInProgress) {
                    return;
                }

                this.isActionInProgress = true;

                setTimeout(() => {
                    // 檢查是否可以過牌
                    if (this.canCheck('bot')) {
                        this.addActionRecord('機器人', '過牌');
                        this.streetActions.add('bot');
                        this.lastAction = 'check';
                        
                        if (this.hasEveryoneActed()) {
                            this.progressGame();
                        } else {
                            this.setCurrentActor('player');
                        }
                        this.updateDisplay();
                        this.isActionInProgress = false;
                        return;
                    }

                    const callAmount = this.currentBetAmount - this.currentBotBet;
                    const random = Math.random();

                    // 在處理完決策邏輯後，先重置動作狀態
                    this.isActionInProgress = false;

                    // 修改機器人的決策邏輯
                    // 只有當有玩家下注時才考慮棄牌
                    if (callAmount > 0 && random < 0.1) { // 10% 機率棄牌，且只在需要跟注時才考慮棄牌
                        this.addActionRecord('機器人', '棄牌');
                        this.playerChips += this.pot;
                        this.pot = 0;
                        this.streetActions.add('bot');
                        this.updateDisplay();

                        setTimeout(() => {
                            this.startNewHand();
                        }, 1500);
                    } else if (random < 0.7) { // 60% 機率跟注/過牌
                        if (callAmount > 0) {
                            const actualCallAmount = Math.min(callAmount, this.botChips);
                            this.pot += actualCallAmount;
                            this.botChips -= actualCallAmount;
                            this.currentBotBet = this.currentBetAmount;
                            this.streetActions.add('bot');
                            this.addActionRecord('機器人', '跟注', actualCallAmount);
                        }
                        
                        if (this.botChips === 0) {
                            this.addActionRecord('機器人', '全壓');
                            this.autoPlayToEnd();
                        } else if (this.hasEveryoneActed()) {
                            this.progressGame();
                        } else {
                            this.setCurrentActor('player');
                        }
                    } else { // 30% 機率加注
                        const minRaise = Math.min(this.currentBetAmount + this.BIG_BLIND, this.botChips + this.currentBotBet);
                        const actualRaiseAmount = minRaise - this.currentBotBet;
                        
                        this.pot += actualRaiseAmount;
                        this.botChips -= actualRaiseAmount;
                        this.currentBetAmount = minRaise;
                        this.currentBotBet = minRaise;
                        this.lastBetPlayer = 'bot';
                        this.streetActions.add('bot');
                        
                        this.addActionRecord('機器人', '加注', actualRaiseAmount);
                        
                        if (this.botChips === 0) {
                            this.addActionRecord('機器人', '全壓');
                            this.autoPlayToEnd();
                        } else {
                            this.setCurrentActor('player');
                        }
                    }

                    this.isActionInProgress = false;
                    this.updateDisplay();
                }, 1000);
            }

            // 新增動畫效果方法
            showActionAnimation(player, action, amount = null) {
                const element = document.createElement('div');
                element.className = 'action-animation';
                element.textContent = `${action}${amount ? ` $${amount}` : ''}`;
                
                // 設置動畫位置
                const position = player === 'bot' ? 
                    document.querySelector('.bot-area') : 
                    document.querySelector('.player-area');
                
                position.appendChild(element);

                // 添加動畫效果
                requestAnimationFrame(() => {
                    element.style.opacity = '0';
                    element.style.transform = 'translateY(-20px)';
                });

                // 移除動畫元素
                setTimeout(() => {
                    element.remove();
                }, 1000);
            }

            // 新增籌碼動畫
            showChipsAnimation(from, to, amount) {
                const chip = document.createElement('div');
                chip.className = 'chip-animation';
                chip.textContent = `$${amount}`;
                
                document.body.appendChild(chip);

                const fromRect = from.getBoundingClientRect();
                const toRect = to.getBoundingClientRect();

                chip.style.left = `${fromRect.left + fromRect.width/2}px`;
                chip.style.top = `${fromRect.top + fromRect.height/2}px`;

                requestAnimationFrame(() => {
                    chip.style.left = `${toRect.left + toRect.width/2}px`;
                    chip.style.top = `${toRect.top + toRect.height/2}px`;
                });

                setTimeout(() => {
                    chip.remove();
                }, 500);
            }

            // 擴展自動完成到底的功能
            autoPlayToEnd() {
                if (this.isAutoPlaying) return;
                this.isAutoPlaying = true;

                // 處理全押情況下的遊戲進程
                const playNextRound = () => {
                    if (this.gameState !== 'showdown') {
                        setTimeout(() => {
                            // 發出所有剩餘的公共牌
                            while (this.communityCards.length < 5) {
                                this.burnCard();  // 每發牌前先銷牌
                                this.communityCards.push(this.deck.deal());
                            }
                            this.gameState = 'showdown';
                            this.determineWinner();
                        }, 1000);
                    }
                };

                playNextRound();
            }

            // 改進遊戲進展邏輯 - 簡化並修正
            progressGame() {
                console.log('Checking game progress...');
                
                // 檢查是否可以進入下一階段
                if (!this.hasEveryoneActed()) {
                    console.log('Not everyone has acted yet');
                    return;
                }

                console.log('Everyone has acted, moving to next stage');

                // 重置當前街口狀態
                this.resetStreetState();
                
                // 根據當前階段進行相應處理
                switch(this.gameState) {
                    case 'preflop':
                        this.dealFlop();
                        break;
                    case 'flop':
                        this.dealTurn();
                        break;
                    case 'turn':
                        this.dealRiver();
                        break;
                    case 'river':
                        this.goToShowdown();
                        break;
                }
            }
            
            // 重置當前階段狀態的輔助方法
            resetStreetState() {
                this.lastAction = null;
                this.currentBetAmount = 0;
                this.currentPlayerBet = 0;
                this.currentBotBet = 0;
                this.streetActions.clear();
                this.actionsThisStreet = [];
            }
            
            // 發翻牌的輔助方法
            dealFlop() {
                this.burnCard();
                this.gameState = 'flop';
                this.currentStreet = 'flop';
                
                const flopCards = [this.deck.deal(), this.deck.deal(), this.deck.deal()];
                this.communityCards = flopCards;
                
                // 為每張牌添加顯示動畫
                flopCards.forEach((card, index) => {
                    setTimeout(() => {
                        const cardElement = document.getElementById(`community${index+1}`);
                        if (cardElement) {
                            cardElement.setAttribute('data-animating', 'true');
                            this.revealCard(cardElement, card);
                            setTimeout(() => {
                                cardElement.removeAttribute('data-animating');
                            }, 600);
                        }
                    }, index * 300);
                });
                
                this.addActionRecord('系統', '發出翻牌');
                
                // 延遲更新顯示和設定下一個行動者
                setTimeout(() => {
                    this.updateDisplay();
                    this.determineFirstActor();
                }, 1000);
            }
            
            // 發轉牌的輔助方法
            dealTurn() {
                this.burnCard();
                this.gameState = 'turn';
                this.currentStreet = 'turn';
                
                const turnCard = this.deck.deal();
                this.communityCards.push(turnCard);
                
                const cardElement = document.getElementById('community4');
                if (cardElement) {
                    cardElement.setAttribute('data-animating', 'true');
                    this.revealCard(cardElement, turnCard);
                    setTimeout(() => {
                        cardElement.removeAttribute('data-animating');
                    }, 600);
                }
                
                this.addActionRecord('系統', '發出轉牌');
                
                // 延遲更新顯示和設定下一個行動者
                setTimeout(() => {
                    this.updateDisplay();
                    this.determineFirstActor();
                }, 1000);
            }
            
            // 發河牌的輔助方法
            dealRiver() {
                this.burnCard();
                this.gameState = 'river';
                this.currentStreet = 'river';
                
                const riverCard = this.deck.deal();
                this.communityCards.push(riverCard);
                
                const cardElement = document.getElementById('community5');
                if (cardElement) {
                    cardElement.setAttribute('data-animating', 'true');
                    this.revealCard(cardElement, riverCard);
                    setTimeout(() => {
                        cardElement.removeAttribute('data-animating');
                    }, 600);
                }
                
                this.addActionRecord('系統', '發出河牌');
                
                // 延遲更新顯示和設定下一個行動者
                setTimeout(() => {
                    this.updateDisplay();
                    this.determineFirstActor();
                }, 1000);
            }
            
            // 進入攤牌階段的輔助方法
            goToShowdown() {
                this.gameState = 'showdown';
                this.addActionRecord('系統', '進入攤牌');
                
                // 直接進入決定贏家的程序
                setTimeout(() => {
                    this.determineWinner();
                }, 500);
            }
            // 在 Game 類別中新增檢查是否所有玩家都行動過的方法 - 修正邏輯
            hasEveryoneActed() {
                // 檢查是否每個玩家都行動過
                const bothActed = this.streetActions.has('player') && this.streetActions.has('bot');
                
                // 確保下注金額相等
                const betsAreEqual = this.currentPlayerBet === this.currentBotBet;
                
                // 在翻牌前階段的特殊處理:
                // 如果有人加注，確保大盲位置的玩家已經有機會行動
                let bigBlindHasChance = true;
                if (this.gameState === 'preflop' && this.currentBetAmount > this.BIG_BLIND) {
                    // 如果大盲位置玩家還沒行動過，或者他是最後一個加注的人，則街口還沒結束
                    bigBlindHasChance = this.streetActions.has(this.bigBlindPosition);
                }
                
                console.log('Action check:', {
                    bothActed,
                    betsAreEqual,
                    bigBlindHasChance,
                    streetActions: Array.from(this.streetActions),
                    playerBet: this.currentPlayerBet,
                    botBet: this.currentBotBet,
                    bigBlindPosition: this.bigBlindPosition
                });
                
                return bothActed && betsAreEqual && bigBlindHasChance;
            }
            
            // 修正後的決定贏家方法
            determineWinner() {
                console.log("Determining winner called..."); 
                
                this.updateGameStatus('攤牌');
                
                // 確保顯示機器人手牌
                const botCard1 = document.querySelector('#bot-card1');
                const botCard2 = document.querySelector('#bot-card2');
                
                if (this.botHand.length > 0 && botCard1 && botCard2) {
                    if (botCard1.querySelector('img')) {
                        this.revealCard(botCard1, this.botHand[0]);
                    }
                    if (botCard2.querySelector('img')) {
                        this.revealCard(botCard2, this.botHand[1]);
                    }
                }
                
                // 確保此處的 setTimeout 不會被跳過
                setTimeout(() => {
                    console.log("Inside winner determination..."); 
                    
                    const playerAllCards = [...this.playerHand, ...this.communityCards];
                    const botAllCards = [...this.botHand, ...this.communityCards];
                    
                    console.log("Player cards:", playerAllCards);
                    console.log("Bot cards:", botAllCards);
                    
                    const playerHand = PokerHand.evaluateHand(playerAllCards);
                    const botHand = PokerHand.evaluateHand(botAllCards);
                    
                    console.log("Player hand:", playerHand);
                    console.log("Bot hand:", botHand);
                    
                    const comparison = PokerHand.compareHands(playerAllCards, botAllCards);
                    
                    console.log("Comparison result:", comparison);
                    
                    // 顯示雙方的牌型
                    const playerHandElem = document.getElementById('player-hand');
                    const botHandElem = document.getElementById('bot-hand');
                    
                    if (playerHandElem) playerHandElem.textContent = `牌型：${playerHand.name}`;
                    if (botHandElem) botHandElem.textContent = `牌型：${botHand.name}`;
                    
                    // 分配獎池
                    if (comparison > 0) {
                        this.playerChips += this.pot;
                        this.addActionRecord('系統', `玩家獲勝 (${playerHand.name} vs ${botHand.name})`);
                        this.updateGameStatus(`恭喜獲勝！你的牌型：${playerHand.name}`);
                        // 添加贏家動畫
                        this.showWinnerAnimation('player');
                    } else if (comparison < 0) {
                        this.botChips += this.pot;
                        this.addActionRecord('系統', `機器人獲勝 (${botHand.name} vs ${playerHand.name})`);
                        this.updateGameStatus(`機器人獲勝！機器人牌型：${botHand.name}`);
                        // 添加贏家動畫
                        this.showWinnerAnimation('bot');
                    } else {
                        const halfPot = Math.floor(this.pot / 2);
                        this.playerChips += halfPot;
                        this.botChips += this.pot - halfPot;
                        this.addActionRecord('系統', `平手 (${playerHand.name})`);
                        this.updateGameStatus(`平手！雙方牌型：${playerHand.name}`);
                    }
                    
                    this.pot = 0;
                    this.updateDisplay();

                    // 檢查遊戲是否結束
                    setTimeout(() => {
                        // 保存當前回合的記錄到歷史記錄中
                        this.roundHistory.unshift({
                            roundNumber: this.roundCount,
                            actions: [...this.currentRoundActions],
                            dealerPosition: this.dealerPosition
                        });
                        
                        if (this.playerChips <= 0) {
                            alert('你輸光了所有籌碼！遊戲結束！');
                            this.resetGame();
                        } else if (this.botChips <= 0) {
                            alert('恭喜你贏得了所有籌碼！');
                            this.resetGame();
                        } else {
                            // 輪換莊家位置
                            this.dealerPosition = this.dealerPosition === 'player' ? 'bot' : 'player';
                            // 更新莊家按鈕位置
                            this.updateDealerPosition();
                            
                            this.isAutoPlaying = false;
                            setTimeout(() => {
                                const playerHandElem = document.getElementById('player-hand');
                                const botHandElem = document.getElementById('bot-hand');
                                if (playerHandElem) playerHandElem.textContent = '';
                                if (botHandElem) botHandElem.textContent = '';
                                this.startNewHand();
                            }, 1500);
                        }
                    }, 2000);
                }, 1000);
            }

            // 修改 canFold 方法
            canFold() {
                // 只有當前有加注需要跟注時才能棄牌
                const callAmount = this.currentBetAmount - this.currentPlayerBet;
                return callAmount > 0;
            }

            burnCard() {
                if (this.deck.cards.length > 0) {
                    this.burnCards.push(this.deck.deal());
                }
            }
            
            // 更新重置遊戲的方法
            resetGame() {
                this.playerChips = 1000;
                this.botChips = 1000;
                this.pot = 0;
                this.playerHand = [];
                this.botHand = [];
                this.communityCards = [];
                this.burnCards = [];
                this.gameState = 'waiting';
                this.roundCount = 0;
                this.isAutoPlaying = false;
                this.dealerPosition = 'player'; // 設置初始莊家
                this.currentRoundActions = [];
                this.roundHistory = [];
                this.currentBetAmount = 0;
                this.currentPlayerBet = 0;
                this.currentBotBet = 0;
                this.lastBetPlayer = null;
                this.streetActions = new Set();
                
                // 重置手牌顯示
                const cards = document.querySelectorAll('.card');
                cards.forEach(card => {
                    card.classList.add('hidden');
                });
                
                // 更新顯示
                this.updateDisplay();
                this.updateDealerPosition(); // 更新莊家按鈕
                this.updateGameStatus('遊戲重新開始');
            }
            
            // 移除 AI 相關代碼，使用簡單規則控制機器人
            getBotDecision() {
                const random = Math.random();
                const callAmount = this.currentBetAmount - this.currentBotBet;
                const stage = this.gameState;
                
                // 基本機率設定
                let foldProb = 0.1;
                let raiseProb = 0.2;
                
                // 根據遊戲階段調整
                if (stage === 'river') {
                    foldProb = 0.15;
                    raiseProb = 0.15;
                }
                
                // 根據下注金額調整（如果下注金額較大，更容易棄牌）
                if (callAmount > this.botChips * 0.3) {
                    foldProb += 0.1;
                    raiseProb -= 0.05;
                }
                
                // 根據剩餘籌碼調整
                if (this.botChips < this.BIG_BLIND * 5) {
                    foldProb -= 0.05;
                    raiseProb += 0.1;
                }
                
                // 只有需要跟注時才可能棄牌
                if (callAmount === 0) {
                    foldProb = 0;
                }
                
                if (random < foldProb) {
                    return 'fold';
                } else if (random < foldProb + raiseProb) {
                    return 'raise';
                } else {
                    return 'call';
                }
            }
        }
        
        // 確保遊戲在頁面加載完成後初始化
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM loaded, initializing game...');
            window.game = new Game();
        });
        
        // 當頁面加載完成時開始遊戲
        window.addEventListener('load', () => {
            console.log('Page loaded, starting game...');
            if (window.game) {
                window.game.initializeGame();
            } else {
                console.error('Game not initialized properly!');
                window.game = new Game();
                window.game.initializeGame();
            }
        });
        
        // 遊戲狀態調試函數
        function debugGameState() {
            const game = window.game;
            if (!game) {
                console.error('Game not initialized!');
                return;
            }
            
            console.log({
                gameState: game.gameState,
                communityCards: game.communityCards.length,
                playerHand: game.playerHand,
                botHand: game.botHand,
                currentActor: game.currentActor,
                hasEveryoneActed: game.hasEveryoneActed(),
                dealerPosition: game.dealerPosition,
                smallBlindPosition: game.smallBlindPosition,
                bigBlindPosition: game.bigBlindPosition
            });
        }
    </script>
</body>
</html>
